<?xml version="1.0"?>
<doc>
    <assembly>
        <name>REghZyPacketSystem</name>
    </assembly>
    <members>
        <member name="T:REghZyPacketSystem.BaseConnection">
            <summary>
            Represents a connection to a data stream, with an ability to connect and disconnect
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.BaseConnection.isDisposed">
            <summary>
            Whether this instance is being disposed or not
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.BaseConnection.Stream">
            <summary>
            The data stream this connection has open
            <para>
            This may be null if <see cref="P:REghZyPacketSystem.BaseConnection.IsConnected"/> returns false
            </para>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.BaseConnection.IsConnected">
            <summary>
            Indicates whether this connection is open or not.
            This also indicates whether the input/output streams are available (they may be null if this is false)
            <para>
            Calling <see cref="M:REghZyPacketSystem.BaseConnection.Connect"/> should result in this being <see langword="true"/>
            </para>
            <para>
            Calling <see cref="M:REghZyPacketSystem.BaseConnection.Disconnect"/> should result in this being <see langword="false"/>
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.BaseConnection.Connect">
            <summary>
            Creates the connection, allowing data to be read and written
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.BaseConnection.Disconnect">
            <summary>
            Breaks the connection, stopping data from being read and written
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.BaseConnection.Restart">
            <summary>
            Disconnects and then connects
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.BaseConnection.Dispose">
            <summary>
            Disposes this connection, releasing all resources that it uses
            <para>
            This also means it cannot be re-connected to
            </para>
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Exceptions.DataLossException">
            <summary>
            An exception used to indicate data loss, typically when reading packets
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Exceptions.PacketCreationException">
            <summary>
            Thrown when the creation of a packet failed
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Exceptions.PacketHandlerException">
            <summary>
            An exception that is thrown when a packet handler failed to handle a packet properly
            <para>
            The inner exception will be the exception that was thrown
            </para>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Exceptions.PacketHandlerException.Packet">
            <summary>
            The packet that was involved (it could be modified since it was received)
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Exceptions.PacketHandlerException.IsListener">
            <summary>
            Whether the handler was a listener. True if so, false if it was a handler
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Exceptions.PacketHandlerException.Priority">
            <summary>
            The priority of the handler/listener that threw the exception
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Exceptions.PacketPayloadException">
            <summary>
            An exception to represent an error with a packet's payload
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.AckProcessor`1">
            <summary>
            A helper class for processing ACK packets. Generally, there should only be 1 instance of the
            AckProcessor per packet type (each implementation is usually a singleton). Atleast, that's the intention
            </summary>
            <typeparam name="TPacket">The type of ACK packet that this processor will processs</typeparam>
        </member>
        <member name="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.Network">
            <summary>
            The packet system that this Ack processor uses
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowResendPacket">
            <summary>
            States whether packets will be re-sent if they aren't received after a specific amount of time (see <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.PacketResendTime"/>)
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.PacketResendTime">
            <summary>
            The amount of time to wait before sending another packet, only if a responce isn't received within this time period (in milliseconds)
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowDuplicatedKey">
            <summary>
            States whether to process packets that use a key that's already been processed
            <para>
            This is false by default
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.SendRequest(`0)">
            <summary>
            Sets up the given packet's key and destination for you, and sends the packet, returning the ID of the packet
            <para>
            This packet is now participating in the ACK transaction, therefore, no other packets should be sent until
            the responce has been received (aka a packet, that this processor processes,
            is received in direction <see cref="F:REghZyPacketSystem.Packeting.Ack.Destination.ToClient"/>)
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.ReceiveResponceAsync(System.UInt32)">
            <summary>
            Asynchronously waits until an ACK packet (of this processor's generic type) is received and whose key is the given key.
            <para>
            See <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowResendPacket"/> to allow re-sending packets if they aren't received after <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.PacketResendTime"/>
            </para>
            </summary>
            <param name="key">
            The key that the received ACK packet (of this processor's generic
            type) must have, in order for this method to return
            </param>
            <returns>
            The packet that the server has sent
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.MakeRequestAsync(`0)">
            <summary>
            Sends a request and awaits its responce asynchronously
            </summary>
            <param name="packet">The packet to send to the server</param>
            <returns>
            The packet sent back from the server
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.SendBackFromAck(`0,`0)">
            <summary>
            A helper function for sending a packet back to the client. It automatically sets the key from <paramref name="fromClient"/>,
            and sets the destination code to <see cref="F:REghZyPacketSystem.Packeting.Ack.Destination.ToClient"/>.
            <para>
            This method just sets the key, and then invokes <see cref="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.SendBackFromAck(`0)"/>
            </para>
            </summary>
            <param name="fromClient">The original packet received from the client</param>
            <param name="toClient">The new packet that contains custom response data</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.SendBackFromAck(`0)">
            <summary>
            A helper function for sending a packet back to the client. It automatically sets the destination for you,
            and then adds the packet to the send packet cache (in case a request is made with the same ID),
            and then sends the given packet again (with the destination code of <see cref="F:REghZyPacketSystem.Packeting.Ack.Destination.ToClient"/>)
            </summary>
            <param name="packet">The packet to send to the client</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.HandleResendPacket(`0)">
            <summary>
            Re-sends the request to the server, usually used if a response not being received
            <para>
            This can be overridden to remove the retransmission functionality (although setting <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowResendPacket"/> would be easier),
            or for altering how packets are re-sent (or removing the console logging)
            </para>
            </summary>
            <param name="packet">
            The packet that was originally sent to the server (the one that was created client side)
            </param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.HandleRepeatIdempotency(`0)">
            <summary>
            Called when a packet is received with an idempotency key that was already processed
            <para>
            The default is to return <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowDuplicatedKey"/>, which defaults to false
            </para>
            </summary>
            <param name="packet">
            The packet (from the client) containing the repeated idempotency key
            </param>
            <returns>
            Whether to continue handling the packet. If false, then stop processing the packet. Otherwise, process it.
            This method just specified what to actually do when a repeated key is received.
            Usually, this method just returns <see cref="P:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.AllowDuplicatedKey"/>. That property isn't checked before this method runs,
            so it's up to this method to check it; it could be true or false
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.OnProcessPacketFromClient(`0)">
            <summary>
            This will be called if we are the server. It is called when we receive a packet from the client,
            aka the mid-way between getting and receiving data (that is, if the ACK packet is used for that)
            <para>
            If the client wanted data (which is usually the usage for ACK packets), the packet in the parameters  will usually
            contain request information, which will be used to fill in data for a new packet, and then be sent to the client
            </para>
            </summary>
            <returns>
            <see langword="true"/> if the packet is fully handled, and should't be sent anywhere else (see <see cref="M:REghZyPacketSystem.Systems.Handling.IHandler.Handle(REghZyPacketSystem.Packeting.Packet)"/>),
            <see langword="false"/> if the packet shouldn't be handled, and can possibly be sent to other handlers/listeners
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.OnProcessPacketFromServer(`0)">
            <summary>
            This will only be called if this is the client. It is called when we (the client)
            receive a packet from the server (usually after the server runs <see cref="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.OnProcessPacketFromClient(`0)"/>)
            <para>
            If the client wanted data (which is usually the usage for ACK packets),
            the packet in the parameters will usually contain the information requested
            </para>
            <para>
            Usually, this method is empty, because you usually use the <see cref="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.ReceiveResponceAsync(System.UInt32)"/>
            method. But that method relies on <see cref="F:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.readCache"/> containing the packet, and the packet is
            only placed in there once this method returns <see langword="true"/>
            </para>
            <para>
            And if this returns <see langword="false"/>, then <see cref="M:REghZyPacketSystem.Packeting.Ack.AckProcessor`1.ReceiveResponceAsync(System.UInt32)"/> will never return,
            essentially meaning you completely ignore the packet (although listeners
            that use <see cref="F:REghZyPacketSystem.Systems.Handling.Priority.HIGHEST"/> will be able to sniff it)
            </para>
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.Attribs.BothSidesAttribute">
            <summary>
            This is used for both client and server side processing
            <para>
            Whether something is client side or server side isn't entirely dependent on which instance of the program is running,
            nor whether packets are sent or received. It depends mostly on what the purpose is.
            </para>
            <para>
            The server can be both a client and a server, so it depends on the perspective
            </para>
            <para>
            In ACK packets, the "client" sends a packet, the "server" receives it and sends a new packet back, and then the "client" receives it.
            But the "server" could also do this too. It could send a packet to the client, the client receives it and sends one back, and the server receives it.
            </para>
            <para>
            So this annotation should be used if the purpose is for both the "client" and "server" (e.g receiving any packet; the client and server both receive packets)
            </para>
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.Attribs.ClientSideAttribute">
            <summary>
            This is only used for client-based processing
            <para>
            Whether something is client side or server side isn't entirely dependent on which instance of the program is running,
            nor whether packets are sent or received. It depends mostly on what the purpose is.
            </para>
            <para>
            The client can be both a client and a server, so it depends on the perspective
            </para>
            <para>
            In ACK packets, the "client" sends a packet, the "server" receives it and sends a new packet back, and then the "client" receives it.
            But the "server" could also do this too. It could send a packet to the client, the client receives it and sends one back, and the server receives it.
            </para>
            <para>
            So this annotation should be used if the purpose is being the "receiver" or "client", independent of what piece of software is running
            </para>
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.Attribs.ServerSideAttribute">
            <summary>
            This is only used for server-based processing
            <para>
            Whether something is client side or server side isn't entirely dependent on which instance of the program is running,
            nor whether packets are sent or received. It depends mostly on what the purpose is.
            </para>
            <para>
            The server can be both a client and a server, so it depends on the perspective
            </para>
            <para>
            In ACK packets, the "client" sends a packet, the "server" receives it and sends a new packet back, and then the "client" receives it.
            But the "server" could also do this too. It could send a packet to the client, the client receives it and sends one back, and the server receives it.
            </para>
            <para>
            So this annotation should be used if the purpose is being the "sender" or "server", independent of what piece of software is running
            </para>
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.Destination">
            <summary>
            The ACK packet direction
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Ack.Destination.ToServer">
            <summary>
            This packet is going to the server
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Ack.Destination.Ack">
            <summary>
            This packet is being acknowledged by the server
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Ack.Destination.ToClient">
            <summary>
            This packet is going to the client
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore">
            <summary>
            A class for efficiently storing idempotency keys
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.highest">
            <summary>
            Used for quickly checking if a key has been used
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node.AddAfter(REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node)">
            <summary>
            Makes this node the given node's next node
            </summary>
            <param name="node">The new previous node</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node.AddBefore(REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node)">
            <summary>
            Makes this node the given node's previous node
            </summary>
            <param name="node">The new next node</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node.Remove">
            <summary>
            Connects the prev and next together, removing this entirely
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node.Invalidate">
            <summary>
            Sets the next and prev nodes to null
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node.InsertBetween(REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node,REghZyPacketSystem.Packeting.Ack.IdempotencyKeyStore.Node)">
            <summary>
            Inserts this node inbetween the 2 other nodes (making sure to connect all of the next/prev nodes of the given nodes too)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.GetPayloadSizeToServer">
            <summary>
            The size of the payload that is being sent to the server. This is
            used if <see cref="F:REghZyPacketSystem.Packeting.Ack.PacketACK.destination"/> is set to <see cref="F:REghZyPacketSystem.Packeting.Ack.Destination.ToServer"/>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.GetPayloadSizeToClient">
            <summary>
            The size of the payload that is being sent to the client. This is
            used if <see cref="F:REghZyPacketSystem.Packeting.Ack.PacketACK.destination"/> is set to <see cref="F:REghZyPacketSystem.Packeting.Ack.Destination.ToClient"/>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.ReadPayloadFromClient(REghZy.Streams.IDataInput,System.UInt16)">
            <summary>
            Reads the data that the client has sent to the server (this will be executed server side)
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.ReadPayloadFromServer(REghZy.Streams.IDataInput,System.UInt16)">
            <summary>
            Reads the data that the server has sent to the client (this will be executed client side)
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.WritePayloadToServer(REghZy.Streams.IDataOutput)">
            <summary>
            Writes the data to the server (this will be executed client side)
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Ack.PacketACK.WritePayloadToClient(REghZy.Streams.IDataOutput)">
            <summary>
            Writes the data to the client (this will be executed server side)
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.Packet">
            <summary>
            A base class for all packets
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Packet.UsePreamble">
            <summary>
            Whether to use the preamble when sending and receiving packets
            <para>
            The preamble allows at least 2 bytes to be lost while reading the very start of the
            packet header, but results in an extra 4 bytes of data being read/written
            </para>
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Packet.MIN_HEADER_LENGTH">
            <summary>
            The absolute minimum size of a packet's header. As of REghZyPacketSystem-2.1, this is 7 bytes
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Packeting.Packet.MAX_PAYLOAD_LENGTH">
            <summary>
            The maximum size of a packet, including the packet header
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.Setup">
            <summary>
            Finds all packet classes in all assemblies attributed with <see cref="T:REghZyPacketSystem.Packeting.PacketImplementation"/> and tries to register them
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.Register``1(System.Byte,System.Func{``0})">
            <summary>
            Registers the given packet ID and the creator. The creator is only used to reduce the use of reflection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="creator"></param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.Register(System.Type,System.Byte,System.Func{REghZyPacketSystem.Packeting.Packet})">
            <summary>
            Registers the given packet ID and the creator. The creator is only used to reduce the use of reflection
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.GetPayloadSize">
            <summary>
            The number of bytes in the packet's payload
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.ReadPayLoad(REghZy.Streams.IDataInput,System.UInt16)">
            <summary>
            Reads all of the packet's payload from the given input.
            The payload length is also specified, because it's sent in the packet header
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.WritePayload(REghZy.Streams.IDataOutput)">
            <summary>
            Writes all of the packet's payload into the given data output
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.WritePacket(REghZyPacketSystem.Packeting.Packet,REghZy.Streams.IDataOutput)">
            <summary>
            Writes the given packet to the given data output
            <para>
            Writes the protocol header, then packet header, and then the packet's payload
            </para>
            </summary>
            <param name="packet">The packet to write</param>
            <param name="output">The data output to write to</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.ReadPacket(REghZy.Streams.IDataInput)">
            <summary>
            Reads a packet from the given data stream
            <para>
            Reads the protocol header, then packet header, and then the packet's payload
            </para>
            </summary>
            <param name="input">The data input to read from</param>
            <returns>
            A packet (non-null)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.UpdateAnnotated">
            <summary>
            Tells the sync table to update all annotated fields/properties with this packet's data, for all targets listening to this type of packet
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.Packet.UpdateAnnotated(System.Object)">
            <summary>
            Tells the sync table to update all annotated fields/properties (for the given target) with this packet's values
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.PacketImplementation">
            <summary>
            A implementation of a packet. This is used to locate unloaded packet classes during app startup
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Packeting.PacketImplementation.UseAutoRegister">
            <summary>
            If true (default value is true), then the packet will be registered automatically once <see cref="M:REghZyPacketSystem.Packeting.Packet.Setup"/> is called
            <para>
            If this is false, then the packet's static constructor will be executed,
            allowing the packet to be registered in there instead of the auto-registration
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketImplementation.TryRegister(System.Type)">
            <summary>
            Attempts to register the packet
            </summary>
            <returns>True if the packet was registered, otherwise false if it was already registered</returns>
        </member>
        <member name="T:REghZyPacketSystem.Packeting.PacketUtils">
            <summary>
            A class for helping with getting the size of objects in bytes
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.GetSizeWL(System.Byte[])">
            <summary>
            Gets the byte array's length with a label
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.GetSizeUTF16WL(System.String)">
            <summary>
            Gets the number of bytes in the string (including the length label size), based on UTF-16 (2 bytes per character)
            </summary>
            <returns>
            2 bytes (length label), plus the length of the string multiplied by 2 (0 if the string is empty).
            This will never return below 2 (due to the length label)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.GetSizeUTF16NL(System.String)">
            <summary>
            Gets the number of bytes in the string (without a length label), based on UTF-16 (2 bytes per character)
            </summary>
            <returns>
            The length of the string multiplied by 2 (0 if the string is empty)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.GetSizeUTF8WL(System.String)">
            <summary>
            Gets the number of bytes in the string (including the length label size), based on UTF-8 (1 byte per character)
            </summary>
            <returns>
            2 bytes (length label), plus the length of the string (0 if the string is empty).
            This will never return below 2 (due to the length label)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.GetSizeUTF8NL(System.String)">
            <summary>
            Gets the number of bytes in the string (without a length label), based on UTF-8 (1 byte per character)
            </summary>
            <returns>
            The length of the string (0 if the string is empty)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.WriteStringUTF16WL(REghZy.Streams.IDataOutput,System.Char[])">
            <summary>
            Writes 2 bytes (a short, being the length of the string), and 2 bytes for each each character of the given char array
            </summary>
            <param name="value">The chars to write</param>
            <param name="output">The data output to write to</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.WriteStringUTF16WL(REghZy.Streams.IDataOutput,System.String)">
            <summary>
            Writes 2 bytes (a short, being the length of the string), and 2 bytes for each character of the given character array
            <para>
            If the given string is null, it will simply write 2 bytes of value '0' (resulting in an empty string being received on the other side)
            </para>
            </summary>
            <param name="value">The string to write</param>
            <param name="output">The data output to write to</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.WriteStringUTF8WL(REghZy.Streams.IDataOutput,System.Char[])">
            <summary>
            Writes 2 bytes (a short, being the length of the string), and 1 byte (the low byte) of each character of the given char array
            </summary>
            <param name="value">The chars to write</param>
            <param name="output">The data output to write to</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.WriteStringUTF8WL(REghZy.Streams.IDataOutput,System.String)">
            <summary>
            Writes 2 bytes (a short, being the length of the string), and 1 byte (the low byte) of each character of the given string
            <para>
            If the given string is null, it will simply write 2 bytes of value '0' (resulting in an empty string being received on the other side)
            </para>
            </summary>
            <param name="value">The string to write</param>
            <param name="output">The data output to write to</param>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.ReadStringUTF16WL(REghZy.Streams.IDataInput)">
            <summary>
            Reads 2 bytes (being the length of a string) as a short value, and reads that many characters (2 bytes per character)
            </summary>
            <param name="input">The data input</param>
            <returns>A string</returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.ReadStringUTF8WL(REghZy.Streams.IDataInput)">
            <summary>
            Reads 2 bytes (being the length of a string) as a short value, and reads that many characters/bytes
            </summary>
            <param name="input">The data input</param>
            <returns>A string</returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.WriteBytesWL(REghZy.Streams.IDataOutput,System.Byte[])">
            <summary>
            Reads 2 bytes (being the length of a string) as a short value, and reads that many bytes
            </summary>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:REghZyPacketSystem.Packeting.PacketUtils.ReadBytesWL(REghZy.Streams.IDataInput)">
            <summary>
            Reads 2 bytes (being the length of a string) as a short value, and reads that many bytes
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:REghZyPacketSystem.Sync.PFTFSyncedAttribute">
            <summary>
            A packet-field to target-field synced attribute
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Sync.PFTPSyncedAttribute">
            <summary>
            A packet-field to target-property synced attribute. This is the most common type of sync attribute
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Sync.PPTFSyncedAttribute">
            <summary>
            A packet-property to target-field synced attribute
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Sync.PPTPSyncedAttribute">
            <summary>
            A packet-property to target-property synced attribute
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Sync.SyncedAttribute">
            <summary>
            An attribute that is to be used on fields or properties, allowing them to be synchronised with packet data
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Sync.SyncedAttribute.PacketType">
            <summary>
            The type of packet that this synchronisation will be paying attention to
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Sync.SyncedAttribute.PacketDataName">
            <summary>
            The name of the field or property that the packet type contains
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Sync.SyncedAttribute.TargetType">
            <summary>
            The target object (aka object that will be updated when a packet of type <see cref="P:REghZyPacketSystem.Sync.SyncedAttribute.PacketType"/> is received)
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Sync.SyncedAttribute.TargetDataName">
            <summary>
            The name of the field or property that the target contains that will be updated
            with <see cref="P:REghZyPacketSystem.Sync.SyncedAttribute.PacketDataName"/> from the packet of type <see cref="P:REghZyPacketSystem.Sync.SyncedAttribute.PacketType"/>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncedAttribute.Update(REghZyPacketSystem.Packeting.Packet,System.Object)">
            <summary>
            Updates the target with the data of the given packet. If the target doesn't use data from the given packet, then it will be ignored
            </summary>
            <param name="packet"></param>
            <param name="target"></param>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncedAttribute.LoadDetails(System.Type,System.String)">
            <summary>
            Loads the target data into this attribute
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Sync.SyncTable">
            <summary>
            A thread-safe helper for creating synchronisation between packets and objects
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncTable.Register(System.Object)">
            <summary>
            Registers the given target, allowing it to receive updates from the given packet type
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncTable.Unregister(System.Object)">
            <summary>
            Unregisters the given target, meaning it will no longer receive updates from packets
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncTable.BroadcastUpdate(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Updates all objects that are listening to the type of the given packet, and only updates the specific target data
            </summary>
            <param name="packet">The packet that targets will receive data from</param>
            <exception cref="T:System.ArgumentNullException">The packet is null</exception>
        </member>
        <member name="M:REghZyPacketSystem.Sync.SyncTable.UpdateFor(REghZyPacketSystem.Packeting.Packet,System.Object)">
            <summary>
            Updates all objects that are listening to the type of the given packet, and updates all of the target data
            </summary>
            <param name="packet">The packet that targets will receive data from</param>
            <exception cref="T:System.ArgumentNullException">The packet is null</exception>
        </member>
        <member name="T:REghZyPacketSystem.Systems.Handling.IHandler">
            <summary>
            An interface for a packet handler
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.Handling.IHandler.CanProcess(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Whether this handler can process the given packet
            </summary>
            <param name="packet"></param>
            <returns>
            <see langword="true"/> if it can (meaning <see cref="M:REghZyPacketSystem.Systems.Handling.IHandler.Handle(REghZyPacketSystem.Packeting.Packet)"/> could be executed without problem),
            otherwise <see langword="false"/>
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.Handling.IHandler.Handle(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Handles the packet
            </summary>
            <param name="packet">The packet (not null)</param>
            <returns>
            <see langword="true"/> if the packet is handled, and shouldn't be processed anymore, otherwise <see langword="false"/>
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.Handling.IListener.OnReceived(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Called when the given packet is received
            </summary>
            <param name="packet">The packet (not null)</param>
        </member>
        <member name="T:REghZyPacketSystem.Systems.Handling.ListenerMap">
            <summary>
            A map, mapping a priority to a collection of listeners and handlers
            <para>
            Listeners of the same priority as handlers will receive packets first, e.g a listener with priotity 1 
            will receive packets first, then handlers or priority 1 will receive packets. But, listeners of priority 2 will
            receive packets AFTER handlers of priority 1
            </para>
            <para>
            The order of received packets being delivered is:
            Listeners(HIGHEST), Handers(HIGHEST), Listeners(HIGH), Handers(HIGH), Listeners(NORMAL),
            Handers(NORMAL), Listeners(LOW), Handers(LOW), Listeners(LOWEST), Handers(LOWEST), 
            </para>
            <para>
            This means listeners have an overall higher priority than handlers of the same 
            priority level, which may be useful for "sniffing" packets before they get handled. Listeners
            cannot cancel the packet (stop them reaching other listeners or handlers) though, only handlers can
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.Handling.ListenerMap.DeliverPacket(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Delivers the given packet to all of the listeners and handlers, respecting their priority
            </summary>
            <param name="packet"></param>
            <returns></returns>
        </member>
        <member name="F:REghZyPacketSystem.Systems.Handling.Priority.HIGHEST">
            <summary>
            This packet must be received first ALL OF THE TIME
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.Handling.Priority.HIGH">
            <summary>
            This packet must be received very soon after coming in
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.Handling.Priority.NORMAL">
            <summary>
            Doesn't really matter. This is typically used for monitoring
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.Handling.Priority.LOW">
            <summary>
            Really doesn't matter at all
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.Handling.Priority.LOWEST">
            <summary>
            Same as low, but even lower
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Systems.PacketSystem">
            <summary>
            The packet network is what handles sending and receiving packets, and delivering received packets to listeners
            <para>
            At it's base level, it's just a wrapper for reading and writing packets from
            a <see cref="T:REghZy.Streams.DataStream"/> (by holding packets in queues). It also contains 
            a map of handlers and listeners too
            </para>
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.PacketSystem.readQueue">
            <summary>
            The packets that have been read/received from the connection, and are ready to be processed
            </summary>
        </member>
        <member name="F:REghZyPacketSystem.Systems.PacketSystem.sendQueue">
            <summary>
            The packets that have been created, and are ready to be sent to the connection
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.PacketSystem.ReadQueue">
            <summary>
            The packets that have been read/received from the connection, and are ready to be processed
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.PacketSystem.SendQueue">
            <summary>
            The packets that have been created, and are ready to be sent to the connection
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.PacketSystem.Connection">
            <summary>
            The connection that this packet system uses
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.PacketSystem.IsConnected">
            <summary>
            Indicates whether this packet's connection is connected or not
            <para>
            Calling <see cref="M:REghZyPacketSystem.Systems.PacketSystem.Start"/> should result in this being <see langword="true"/>
            </para>
            <para>
            Calling <see cref="M:REghZyPacketSystem.Systems.PacketSystem.Stop"/> should result in this being <see langword="false"/>
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.#ctor(REghZyPacketSystem.BaseConnection)">
            <summary>
            Creates a new instance of a packet system
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.Start">
            <summary>
            Starts the packet system. By default, this just calls <see cref="M:REghZyPacketSystem.BaseConnection.Connect"/>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.Stop">
            <summary>
            Stops the packet system. By default, this just calls <see cref="M:REghZyPacketSystem.BaseConnection.Disconnect"/>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.ReadNextPacket">
            <summary>
            Reads the next available packet, and enqueues it in <see cref="P:REghZyPacketSystem.Systems.PacketSystem.ReadQueue"/>
            </summary>
            <returns>
            True if a packet was read, otherwise false (if there wasn't enough data available to read a packet header)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.ReadNextPackets(System.Int32)">
            <summary>
            Tries to read a maximum of the given number of packets, unless there isn't enough data to read
            </summary>
            <returns>
            The number of packets that were queued in <see cref="P:REghZyPacketSystem.Systems.PacketSystem.ReadQueue"/>
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.ProcessReadQueue(System.Int32)">
            <summary>
            Processes/handles the given number of packets that are currently queued in <see cref="P:REghZyPacketSystem.Systems.PacketSystem.ReadQueue"/>
            <para>
            If the packet system is used with WPF, or in a non-thread-safe environment, this method should
            only be run on the safe thread (e.g WPF's main thread/GUI thread)
            </para>
            </summary>
            <param name="count">The number of packets to try and handle</param>
            <returns>
            The number of packets that were handled. This may not be equal to the
            given number of packets (e.g there weren't enough packets in the queue)
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.ProcessSendQueue(System.Int32)">
            <summary>
            <para>
            If using a <see cref="T:REghZyPacketSystem.Systems.ThreadPacketSystem"/>, this will be invoked by the write thread, so manually
            calling it isn't strictly necessary. Otherwise, see <see cref="M:REghZyPacketSystem.Systems.PacketSystem.SendPacketImmidiately(REghZyPacketSystem.Packeting.Packet)"/>
            </para>
            </summary>
            <param name="count">The number of packets to try and write</param>
            <exception cref="T:REghZyPacketSystem.Exceptions.PacketWriteException"></exception>
            <returns>
            The number of packets that were handled. This may not be equal to the given number of packets
            </returns>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.SendPacket(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Queues a packet to be sent (adds it to <see cref="P:REghZyPacketSystem.Systems.PacketSystem.SendQueue"/>)
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:REghZyPacketSystem.Systems.PacketSystem.SendPacketImmidiately(REghZyPacketSystem.Packeting.Packet)">
            <summary>
            Immidiately sends a packet to the connection in this packet system.
            This simply calls <see cref="M:REghZyPacketSystem.Packeting.Packet.WritePacket(REghZyPacketSystem.Packeting.Packet,REghZy.Streams.IDataOutput)"/>
            <para>
            This method is blocking; you won't be able to do anything until ALL of the bytes have been written
            </para>
            </summary>
            <param name="packet">The packet to send (non-null)</param>
        </member>
        <member name="T:REghZyPacketSystem.Systems.ThreadPacketSystem">
            <summary>
            An extension to the <see cref="T:REghZyPacketSystem.Systems.PacketSystem"/>, using a read and write thread to enqueue packets
            that have been read from the connection, and to also sending packets to the connection
            <para>
            This prevents the main/important thread from having to wait for packets to be written and read; now it
            just has to process the packets (see below)
            </para>
            <para>
            This does not poll/process any packets, that must be done manually (because packet handlers/listeners
            aren't thread safe), via the <see cref="M:REghZyPacketSystem.Systems.PacketSystem.ProcessReadQueue(System.Int32)"/> method
            </para>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.Disposed">
            <summary>
            Whether this has been disposed or not
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.WriteCount">
            <summary>
            The number of packets that the write thread should try to send each time
            <para>
            See the comments on <see cref="M:REghZyPacketSystem.Systems.PacketSystem.ProcessSendQueue(System.Int32)"/>, this may not be the exact
            number of packets that get written every time. The ability to write more than 1 is only for extra speed... maybe
            </para>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.CanRead">
            <summary>
            Sets whether the read thread can run or not. If set to <see langword="false"/>, it will not stop
            the thread, it will simply sit at idle until this becomes <see langword="true"/>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.CanSend">
            <summary>
            Sets whether the send/write thread can run or not. If set to <see langword="false"/>, it will not stop
            the thread, it will simply sit at idle until this becomes <see langword="true"/>
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.PacketsRead">
            <summary>
            The exact number of packets that have been read
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.PacketsSent">
            <summary>
            The exact number of packets that have been sent
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.ReadThread">
            <summary>
            The thread used to read packets
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.SendThread">
            <summary>
            The thread used to send packets
            </summary>
        </member>
        <member name="P:REghZyPacketSystem.Systems.ThreadPacketSystem.Paused">
            <summary>
            Sets whether reading and writing packets is paused or not.
            <para>
            <see langword="false"/> means nothing can be read or written.
            <see langword="true"/> means packets can be read and written
            </para>
            </summary>
        </member>
        <member name="E:REghZyPacketSystem.Systems.ThreadPacketSystem.OnPacketReadError">
            <summary>
            Called when an exception was thrown while reading a packet from the connection
            <para>
            This will be invoked from the read thread, therefore you must ensure your code is thread safe!
            </para>
            </summary>
        </member>
        <member name="E:REghZyPacketSystem.Systems.ThreadPacketSystem.OnPacketWriteError">
            <summary>
            Called when an exception was thrown while writing a packet to the connection
            <para>
            This will be invoked from the write thread, therefore you must ensure your code is thread safe!
            </para>
            </summary>
        </member>
        <member name="E:REghZyPacketSystem.Systems.ThreadPacketSystem.OnReadAvailable">
            <summary>
            Called when there are packets available to be read in <see cref="P:REghZyPacketSystem.Systems.PacketSystem.ReadQueue"/>
            <para>
            This event will be called from another thread, therefore you must ensure your code is thread safe!
            </para>
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.#ctor(REghZyPacketSystem.BaseConnection,System.Int32)">
            <summary>
            Creates a new instance of the threaded packet system
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.Start">
            <summary>
            Starts the base packet system, and both the read and write threads
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.Stop">
            <summary>
            Disconnects from the connection, and stops the read and write threads
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.PauseThreads">
            <summary>
            Sets <see cref="P:REghZyPacketSystem.Systems.ThreadPacketSystem.Paused"/> to true, stopping the threads from reading and writing
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.UnpauseThreads">
            <summary>
            Sets <see cref="P:REghZyPacketSystem.Systems.ThreadPacketSystem.Paused"/> to false, allowing the threads to read and write again
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.Dispose">
            <summary>
            Disconnects and kills the threads used with this Threaded packet system
            </summary>
        </member>
        <member name="M:REghZyPacketSystem.Systems.ThreadPacketSystem.DoThreadDelay">
            <summary>
            Used by the read and write threads to delay them, so that they aren't running at 100% all the time, consuming resources
            </summary>
        </member>
        <member name="T:REghZyPacketSystem.Utils.Enums`1">
            <summary>
            A class for converting between enum and primitives (int/short/etc)
            </summary>
            <typeparam name="TEnum"></typeparam>
        </member>
    </members>
</doc>
